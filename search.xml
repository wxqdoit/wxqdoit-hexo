<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年终总结]]></title>
    <url>%2F20200208%2F2019%2F</url>
    <content type="text"><![CDATA[搬家2019-11 对，我又搬家了 工作2019-06 对 我又换工作了 刷剧《我和僵尸有个约会1》 《我和僵尸有个约会3》 《非自然死亡》 《带着爸爸去留学》 《惊蛰》 电影、纪录片《哪吒之魔童降世》（电影院） 《流浪地球》 《中国机长》 《飞驰人生》 《攀登者》 《银河补习班》 《白蛇：缘起》 《老师·好》 《大人物》 《人生果实》 《了不起的盖茨比》 《星际穿越》 《闪光少女》 《百鸟朝凤》 《妈阁是座城》 《第一滴血1-3》 《楚门的世界》 《道士下山》 《我的喜马拉雅》 《一条狗的使命》 《我是山姆》 《恋爱回旋》 读书《我是猫》 《了不起的盖茨比》 《白夜行》 《时间简史》 追番《鬼灭之刃》 《重来吧！魔王大人》 《这个勇者明明超强却过分慎重》 《流汗吧！健身少女》 《罗小黑战记》 《我们仍未知道那天所看见的花的名字》 《博人传》 活动、旅行、出差2019-02 自贡 2019-04 西安 2019-05 色达 2019-05 贵阳数博会 2019-07 上海IPFS会议 2019-12 成都BW]]></content>
      <categories>
        <category>记事簿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅探NPM]]></title>
    <url>%2F20190226%2Fnpm%2F</url>
    <content type="text"><![CDATA[今晩はお月さん var ap = new APlayer({ element: document.getElementById("aplayer-oBtooUeY"), narrow: false, autoplay: false, showlrc: false, music: { title: "今晩はお月さん", author: "ハンバート", url: "https://wxqdoit-blog-1252754215.cos.ap-chengdu.myqcloud.com/2019/705a_b88c_b84e_ced8f9e08c9e6c9970ee894a66361a6a.mp3", pic: "https://wxqdoit-blog-1252754215.cos.ap-chengdu.myqcloud.com/2019/703687441788470.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 先放松一心情，听一首有趣的歌！ 包管理器如果使用过Gradle，一定对下面的配置很容易理解：1234567891011121314151617181920212223242526272829303132333435363738//用于构建项目的插件apply plugin: &apos;java&apos;apply plugin: &apos;spring-boot&apos;apply plugin: &apos;idea&apos;apply plugin: &apos;war&apos;buildscript &#123; repositories &#123; mavenCentral() maven &#123; url &quot;https://repo.spring.io/plugins-release&quot; &#125; &#125; //指定gradle插件的版本 dependencies &#123; classpath(&apos;io.spring.gradle:dependency-management-plugin:0.6.1.RELEASE&apos;) classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.3.2.RELEASE&quot;) &#125;&#125;//构建脚本中所依赖库在jcenter仓库下载repositories &#123; jcenter()&#125;//指定当前项目的依赖dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter&quot;) compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;) compile(&apos;mysql:mysql-connector-java:5.1.38&apos;) compile(&apos;commons-fileupload:commons-fileupload:1.3.1&apos;) compile(&apos;com.alibaba:fastjson:1.2.7&apos;) compile(&quot;org.springframework.boot:spring-boot-starter-velocity&quot;)&#125;tasks.withType(JavaCompile) &#123; sourceCompatibility = &apos;1.8&apos; targetCompatibility = &apos;1.8&apos;&#125; 如果使用过Maven，一定对下面的配置很容易理解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;FruitShop&lt;/groupId&gt; &lt;artifactId&gt;FruitShop&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;FruitShop Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;shiro.version&gt;1.2.5&lt;/shiro.version&gt; &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Logging API + implementation: --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库连接的包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;FruitShop&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--idea能够编译非resources中的xml文件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; Gradle和Maven都是Java Web项目的构建工具，当然还有Ant，Gradle还作为Android项目的官方构建工具。 所以如果熟悉Gradle和Maven，那么对NPM就非常容易理解。 NPM前世今生NPM（Node Package Manager） 作为NodeJs的包管理器，伴随着Node的诞生而诞生，内置于Node中，当安装好Node之后，NPM也就对应安装好了。但是具体在哪个版本中内置的我没有找到（请大佬告诉我）。下面是NPM的最初版本： Yarn与CNPM Yarn可以理解为NPM的远房表亲，同样是包管理器（但我就是不用你）。 CNPM是淘宝对NPM做的国内镜像，主要为了解决国内开发者使用NPM下载依赖中超时等问题。但是使用CNPM下载安装各种依赖包时有可能会出现莫名其妙的错误。 NPM项目 初始化项目，命令行输入：npm init，然后一顿回车 123456789101112131415161718192021222324252627282930313233343536373839D:\dev&gt;cd npm-testD:\dev\npm-test&gt;npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (npm-test)version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to D:\dev\npm-test\package.json:&#123; &quot;name&quot;: &quot;npm-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125;Is this ok? (yes)D:\dev\npm-test&gt; 此时已经初始化好了项目，并自动生成了package.json文件 1234567891011&#123; &quot;name&quot;: &quot;npm-test&quot;, //项目名 &quot;version&quot;: &quot;1.0.0&quot;, //版本号 &quot;description&quot;: &quot;&quot;, //项目描述 &quot;main&quot;: &quot;index.js&quot;, //入口文件 &quot;scripts&quot;: &#123; //定义脚本命令 &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, //作者 &quot;license&quot;: &quot;ISC&quot; //开放源代码许可证 ISC&#125; 其中scripts的配置里面有一个test字段，当我们在命令行输入npm run test会输出echo &quot;Error: no test specified&quot; &amp;&amp; exit 1 12345678910111213141516171819D:\dev\npm-test&gt;npm run test&gt; npm-test@1.0.0 test D:\dev\npm-test&gt; echo &quot;Error: no test specified&quot; &amp;&amp; exit 1&quot;Error: no test specified&quot;npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! npm-test@1.0.0 test: `echo &quot;Error: no test specified&quot; &amp;&amp; exit 1`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the npm-test@1.0.0 test script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm WARN Local package.json exists, but node_modules missing, did you mean to install?npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\wxqdoit\AppData\Roaming\npm-cache\_logs\2019-02-26T06_46_24_718Z-debug.logD:\dev\npm-test&gt; 将scripts下改成:&quot;build&quot;: &quot;node index.js&quot;，再在项目目录下新建index.js，并编写如下代码 12345678function closure()&#123; var a = 1; return function()&#123; console.log(a) &#125;&#125;//内部函数引用外部函数的变量,并返回自身，なに、大名鼎鼎的闭包？closure()() 在命令行输入npm run build，记住是npm run +自定义命令 12345678D:\dev\npm-test&gt;npm run build&gt; npm-test@1.0.0 build D:\dev\npm-test&gt; node index.js1D:\dev\npm-test&gt; 姿势摆好，准备进入正题了 安装依赖 安装express：npm install express 很快就安装好了，打开package.json文件发现里面多了如下依赖,同时也自动生成了node_modules文件夹。很多资料说npm install xxx只是安装到node_modules目录中不会添加package.json到中，而 npm install xxx --save会添加到package.json中，但是我每次执行npm install xxx都修改了package.json 123&quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.4&quot;&#125; 下面我们执行npm install express --save-dev，安装完成后查看package.json，发现将express转移到了devDependencies里面 1234&quot;dependencies&quot;: &#123;&#125;,&quot;devDependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.4&quot;&#125; 所以总结如下 npm install xxx 在我的环境下等同于npm install xxx --save会安装到dependencies里面 npm install xxx --save 项目实际上线后需要依赖的包请使用这条命令安装 npm install xxx --save-dev 项目实际上线后【不】需要依赖的包请使用这条命令安装 dependencies代表生成环境 devDependencies代表开发环境 现在将express转到dependencies里面：npm install express --save 试了几次之后发现npm install express --save根本没有起作用，所以我npm uninstall express再npm install express --save NPM模块安装机制 发出npm install命令 检测package.json依赖 查询node_modules目录之中是否已经存在指定模块 若存在，不再重新安装 若不存在 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在根目录下的.npm目录里 解压压缩包到当前项目的node_modules目录 NPM有哪些命令呢，命令行输入npm，简写命令在Node安装目录\node_modules\npm\lib\config\cmd-list.js可以看到 1234567891011121314D:\dev\npm-test&gt;npmUsage: npm &lt;command&gt;where &lt;command&gt; is one of: access, adduser, bin, bugs, c, cache, completion, config, ddp, dedupe, deprecate, dist-tag, docs, doctor, edit, explore, get, help, help-search, i, init, install, install-test, it, link, list, ln, login, logout, ls, outdated, owner, pack, ping, prefix, profile, prune, publish, rb, rebuild, repo, restart, root, run, run-script, s, se, search, set, shrinkwrap, star, stars, start, stop, t, team, test, token, tst, un, uninstall, unpublish, unstar, up, update, v, version, view, whoami 打开你的Node安装目录，仔细分析发现NPM其实就是一个Node应用。那我们的npm install究竟干了什么呢，当你安装完Node，就在系统中注册了npm命令。打开Node安装目录\node_modules\npm\bin,有npm.cmd文件与npm-cli.js文件npm.cmd入口 123456789101112131415161718192021222324252627:: Created by npm, please don&apos;t edit manually.//关闭回显@ECHO OFF//本地化SETLOCAL//%~dp0代表当前位置SET &quot;NODE_EXE=%~dp0\node.exe&quot;IF NOT EXIST &quot;%NODE_EXE%&quot; ( SET &quot;NODE_EXE=node&quot;)//&apos;CALL &quot;%NODE_EXE%&quot; &quot;%NPM_CLI_JS%&quot; prefix -g&apos;这一行在npm.cmd起的作用是//如果能运行这两个命令并且得到结果的话将NPM_PREFIX_NPM_CLI_JS的值设置//为&quot;\node_modules\npm\bin\npm-cli.js&quot;SET &quot;NPM_CLI_JS=%~dp0\node_modules\npm\bin\npm-cli.js&quot;FOR /F &quot;delims=&quot; %%F IN (&apos;CALL &quot;%NODE_EXE%&quot; &quot;%NPM_CLI_JS%&quot; prefix -g&apos;) DO ( SET &quot;NPM_PREFIX_NPM_CLI_JS=%%F\node_modules\npm\bin\npm-cli.js&quot;)IF EXIST &quot;%NPM_PREFIX_NPM_CLI_JS%&quot; ( SET &quot;NPM_CLI_JS=%NPM_PREFIX_NPM_CLI_JS%&quot;)&quot;%NODE_EXE%&quot; &quot;%NPM_CLI_JS%&quot; %* 12345678910111213//现在实际启动npm并运行命令 //这是如何以编程方式使用npm：conf._exit = truenpm.load(conf, function (er) &#123; if (er) return errorHandler(er) npm.commands[npm.command](npm.argv, function (err) &#123; // https://www.youtube.com/watch?v=7nfPu8qTiQU if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') &#123; output('\n 🎵 I Have the Honour to Be Your Obedient Servant,🎵 ~ npm 📜🖋\n') &#125; errorHandler.apply(this, arguments) &#125;)&#125;) 打开Node安装目录\node_modules\npm\lib，找到install.js文件（细心的你可能已经发现了基本上每一个js文件对应了上述的一个命令），用编辑器打开install.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101'use strict'// npm install &lt;pkg&gt; &lt;pkg&gt; &lt;pkg&gt;//// See doc/cli/npm-install.md for more description//// Managing contexts...// there's a lot of state associated with an "install" operation, including// packages that are already installed, parent packages, current shrinkwrap, and// so on. We maintain this state in a "context" object that gets passed around.// every time we dive into a deeper node_modules folder, the "family" list that// gets passed along uses the previous "family" list as its __proto__. Any// "resolved precise dependency" things that aren't already on this object get// added, and then that's passed to the next generation of installation.module.exports = installmodule.exports.Installer = Installervar usage = require('./utils/usage')install.usage = usage( 'install', '\nnpm install (with no args, in package dir)' + '\nnpm install [&lt;@scope&gt;/]&lt;pkg&gt;' + '\nnpm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;' + '\nnpm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;' + '\nnpm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;' + '\nnpm install &lt;folder&gt;' + '\nnpm install &lt;tarball file&gt;' + '\nnpm install &lt;tarball url&gt;' + '\nnpm install &lt;git:// url&gt;' + '\nnpm install &lt;github username&gt;/&lt;github project&gt;', '[--save-prod|--save-dev|--save-optional] [--save-exact] [--no-save]')//175行定义install方法，这个方法进入核心的install逻辑function install (where, args, cb) &#123; if (!cb) &#123; cb = args args = where where = null &#125; var globalTop = path.resolve(npm.globalDir, '..') if (!where) &#123; where = npm.config.get('global') ? globalTop : npm.prefix &#125; validate('SAF', [where, args, cb]) // the /path/to/node_modules/.. var dryrun = !!npm.config.get('dry-run') if (npm.config.get('dev')) &#123; log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--only=dev` instead.') &#125; if (where === globalTop &amp;&amp; !args.length) &#123; args = ['.'] &#125; args = args.filter(function (a) &#123; return path.resolve(a) !== npm.prefix &#125;) new Installer(where, dryrun, args).run(cb)&#125;//205行定义了Installer类function Installer (where, dryrun, args, opts) &#123;&#125;//358行 跟踪器创建Installer.prototype.newTracker = function (tracker, name, size) &#123; validate('OS', [tracker, name]) if (size) validate('N', [size]) this.progress[name] = tracker.newGroup(name, size) return function (next) &#123; process.emit('time', 'stage:' + name) next() &#125;&#125;Installer.prototype.finishTracker = function (name, cb) &#123; validate('SF', arguments) process.emit('timeEnd', 'stage:' + name) cb()&#125;Installer.prototype.loadCurrentTree = function (cb) &#123; validate('F', arguments) log.silly('install', 'loadCurrentTree') var todo = [] if (this.global) &#123; todo.push([this, this.readGlobalPackageData]) &#125; else &#123; todo.push([this, this.readLocalPackageData]) &#125; todo.push([this, this.normalizeCurrentTree]) chain(todo, cb)&#125;//387行 创建nodevar createNode = require('./install/node.js').create 下面是官方介绍 This command installs a package, and any packages that it depends on. If thepackage has a package-lock or shrinkwrap file, the installation of dependencieswill be driven by that, with an npm-shrinkwrap.json taking precedence if bothfiles exist. See package-lock.json(5) and npm-shrinkwrap(1). A package is: a) a folder containing a program described by a package.json(5) file b) a gzipped tarball containing (a) c) a url that resolves to (b) d) a &lt;name&gt;@&lt;version&gt; that is published on the registry (see npm-registry(7)) with (c) e) a &lt;name&gt;@&lt;tag&gt; (see npm-dist-tag(1)) that points to (d) f) a &lt;name&gt; that has a “latest” tag satisfying (e) g) a &lt;git remote url&gt; that resolves to (a) 总结下来就是： 执行工程自身 确定首层依赖模块 根据模块信息递归网络获取模块 模块扁平化，解决重复冗余问题 安装模块，更新node_modules 自身生命周期，生成或更新package.json 参考文章Maven和Gradle对比 第20题：介绍下 npm 模块安装机制 Node.js npm 详解;]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客迁移]]></title>
    <url>%2F20190216%2Fmigrate%2F</url>
    <content type="text"><![CDATA[这两天一直在弄博客迁移，总算是肝好了 服务迁移之前的博客是我自己用Node搭建的，虽然说功能都有，但是也只能玩玩。 现在换到了Hexo(虽然hexo也是node搭建的 服务器托管由我1M的小水管迁移到github上了，准备把自己的服务器用来做点别的。 域名迁移从 https://www.wxqdoit.com 改成 https://www.wxqdoit.cn 就是从 .com 变为 .cn 啦，话说又得续费了！ 资源迁移之前的图片什么的都存在我自己的服务器上，现在大部分都使用了CDN。]]></content>
      <categories>
        <category>记事簿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019春节之旅]]></title>
    <url>%2F20190209%2F2019SpringFestival%2F</url>
    <content type="text"><![CDATA[回家了2月2号从成都赶回宜宾，下午和高中几个同学吃了一顿饭。 有赖子，蛋蛋，刘哥，致均。吃完饭回去乡下就晚上九点过了。 在家这几天到家后的两三天也没干啥就过去了，去了趟外公家，大年三十晚上放了一串鞭炮，然后就接着刷剧了。 初一在家，早晚吃了抄手，中午吃的汤圆。 初二去了五孃家。 初三一些亲戚来我家，我忙了一天。 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"https://wxqdoit-blog-1252754215.cos.ap-chengdu.myqcloud.com/75691872-1-6.mp4.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 自贡这一天前一两天我买了初四也就是8号到自贡的汽车票，我给家里人说回成都。年前同学就叫我去自贡耍，然后我说有时间的话，如果你也不忙我就来玩一天，所以就去了，其实还是很期待的。上次和大家一起聚还是在18年4月还是多久来着，我都忘了。 所以8号我老早就起床收拾出发，先是去镇上买了一些特产，虽然很low，然后挤公交到了市里汽车站，真的把我累着了。 大概坐了两个小时的车先到了自贡，然后过了几分钟朋友来接的我。之后我把东西放宾馆，带我去了一家饭馆点了两个菜，接着我就一个人在那吃饭。 吃了好久呆呆打车过来了。然后去了咖啡馆，尬坐了一个多小时。 没多久兰姐也到了，然后我们就在公园里面瞎逛吹牛。 晚饭吃的很好，点了很多干锅，兔子什么的，味道还是不错。吃完饭之后先是去了理工大学，爬了一段小山，然后和波波开了视频。大家都很开心 然后打车去了网红桥，人巨多。 走到第二个上去之后就坐公交车回去了 Say, goodbye。 回到住处想了很多，不知道自己是个什么玩意儿，很累，没有方向，今年又将会怎样我实在是难以猜测。希望自己能活的开心一点吧，希望有些总还是能实现的吧。 感谢过去这一年的每一张笑脸。]]></content>
      <categories>
        <category>记事簿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018年终总结]]></title>
    <url>%2F20190201%2F2018%2F</url>
    <content type="text"><![CDATA[毕业6月份毕业了 论文修改… 论文答辩… 领取学位证… 搬家5月初搬出了与同学的合租房，一个人在自如租了个单间 7月底从自如搬出，又和另外两同学一起合租 工作3月初还了工作 从前端到小游戏 刷剧《逃避可耻但很有用》 《将夜》 电影《爱情公寓》 《古墓丽影：源起之战》 读书《克苏鲁神话》 《时间简史》 《安娜·卡列尼娜》（这本书我整整看了一年） 《万历十五年》 《诗经》（读了一部分） 《小王子》 《史蒂夫·乔布斯传》 《淘宝技术这十年》 《腾讯传》 《普京传》 追番《火影忍者·博人传》 《卫宫家今天的饭》 《千绪的通学路》 《工作细胞》 《后街女孩》 《青春猪头少年不会梦到兔女郎学姐》 《关于我转生变成史莱姆这档事》 《一人之下》 活动八月，开源中国原创会&amp;数博会 五月，成都欢乐谷 三月，桃花故里 一月，兴隆湖]]></content>
      <categories>
        <category>记事簿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发Hybrid App的技术选型]]></title>
    <url>%2F20181224%2FHybridApp%2F</url>
    <content type="text"><![CDATA[一、前言如果我们把Hybrid App理解为运行在android或者ios以及其他移动终端设备上的应用，也可以叫做H5 APP，这种开发应用的模式结合web开发技术与Native开发的部分技术，通常也被称为混合开发模式。 二、移动应用开发的三种方式 Native App：原生应用，在android端通常使用Java或Kotlin开发，ios端使用OC或者Swift开发 Hybrid App：混合应用，结合Web与Native技术开发 Web App：web应用，网页三剑客html+css+js Native App开发依旧是移动应用的主导，但如今的Native App或多或少会嵌入一些web页面，诸如淘宝、京东等APP，所以如今真正意义上的原生应用又该如何去定义呢？Hybrid App受到越来越多开发者的追捧与其开发周期短，开发难度小，跨平台离不开，当然APP的效果也成为大家诟病的话题，如首屏打开缓慢，动画效果不够流畅等。 三种方式的技术比较（图片来自网络） 三、Hybrid App开发的核心毫无疑问，webview是Hybrid App开发的核心。webview可以简单的理解为一个浏览器。webview 使用的是手机自带的浏览器内核，一般来说，手机厂家在内置浏览器的时候都会对其内核做一定的修改，所以在webview渲染的内容可能或有些差异，但是这基本上不影响APP的开发。绝大部分手机都使用的是WebKit作为webview的渲染引擎。关于WebKit以及其他的浏览器内核知识可以查看这里。 关于webview的知识点非常多，如在android上常用的属性：WebSettings、WebViewClient，与JavaScript的交互，js注入漏洞，jsBridge等等，在此以Kotlin为例实现一个简单的例子，项目源码点击这里。 MAinActivity.kt 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.wxqdoit.kotlintestimport android.os.Buildimport android.os.Bundleimport android.support.annotation.RequiresApiimport android.support.design.widget.BottomNavigationViewimport android.support.v4.app.Fragmentimport android.support.v7.app.AppCompatActivityimport android.widget.Toastimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; @RequiresApi(Build.VERSION_CODES.O) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) bottom_navigation.setOnNavigationItemSelectedListener(mBottomNavigationView) val fragments: MutableList&lt;Fragment&gt; = ArrayList&lt;Fragment&gt;() fragments.add(Fragment1("https://www.baidu.com")) fragments.add(Fragment1("https://www.jianshu.com")) fragments.add(Fragment1("https://aidn.jp/mikutap/")) vp_main.adapter = ViewPagerAdapter(supportFragmentManager,fragments) &#125; private val mBottomNavigationView = BottomNavigationView.OnNavigationItemSelectedListener &#123; item -&gt; when (item.itemId) &#123; R.id.word -&gt; &#123; //vp_main.currentItem = 0 Toast.makeText(this,"点击了",Toast.LENGTH_SHORT).show() return@OnNavigationItemSelectedListener true &#125; R.id.pic -&gt; &#123; //vp_main.currentItem = 1 return@OnNavigationItemSelectedListener true &#125; R.id.me -&gt; &#123; //vp_main.currentItem = 2 return@OnNavigationItemSelectedListener true &#125; &#125; false &#125;&#125; ViewPagerAdapter.kt 12345678910111213package com.example.wxqdoit.kotlintestimport android.support.v4.app.Fragmentimport android.support.v4.app.FragmentManagerimport android.support.v4.app.FragmentPagerAdapter//继承 FragmentPagerAdapter 创建适配器class ViewPagerAdapter(fm: FragmentManager?, var list: List&lt;Fragment&gt;) : FragmentPagerAdapter(fm) &#123; override fun getItem(position: Int): Fragment &#123; return list.get(position) &#125; override fun getCount(): Int &#123; return list.size &#125;&#125; Fragment1.kt 1234567891011121314151617181920212223242526272829303132333435package com.example.wxqdoit.kotlintestimport android.annotation.SuppressLintimport android.os.Buildimport android.os.Bundleimport android.support.annotation.RequiresApiimport android.support.v4.app.Fragmentimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.webkit.WebResourceRequestimport android.webkit.WebViewimport android.webkit.WebViewClientimport kotlinx.android.synthetic.main.fragment1.view.*@SuppressLint("ValidFragment")class Fragment1(private val url: String):Fragment() &#123; @SuppressLint("SetJavaScriptEnabled") @RequiresApi(Build.VERSION_CODES.O) override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val view = inflater.inflate(R.layout.fragment1, container, false) val webView = view.testWebView webView!!.webViewClient = webClient webView.settings.javaScriptEnabled = true webView.settings.allowContentAccess = true webView.settings.layoutAlgorithm webView.loadUrl(url) return view &#125; private val webClient = object : WebViewClient() &#123; @RequiresApi(Build.VERSION_CODES.LOLLIPOP) override fun shouldOverrideUrlLoading(view: WebView, request:WebResourceRequest ): Boolean &#123; view.loadUrl(request.url.toString()) return true &#125; &#125;&#125; 效果如下 四、移动APP适配做过原生开发的都知道美术需要出几套图以适配不同的分辨率，720×1280、750×1334、1080×1920、1242×2208，更大或者更小的屏在市面上也常见，android上字体大小通常以dp、sp作为单位。Hybrid App在只有一套美术UI的情况下应当如何处理以适配不同的机型呢？ 媒体查询、百分比，或是直接使用web端常用的单位px、em、rem以及vh、vw，都是常用的适配方案。在设计稿给到固定宽度的情况下，相对而言，使用rem作为单位是比较合理的选择，至于移动设备适配，屏幕宽度，逻辑像素、物理像素、dpi等知识就不在此处赘述，分享优秀的博客： 移动设备适配基础知识速成：weibo.com/p/1001603933391216084991 五、flexible.jsflexible是淘宝使用的移动端适配方案，原理即根据机型分辨率进行适配，设置根font-size，使用相对单位rem。其核心功能如下： 判断meta标签，动态改写标签 给html标签添加data-dpr属性 给html标签添加font-size属性 根font-size（即html标签上的）属性值即为一个单位的rem，在chrome浏览器上，默认的font-size值为16px：即16px=1rem 12getComputedStyle(document.getElementsByTagName("html")[0])["font-size"];//16px flexible.js核心代码： 1234567891011121314151617181920function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; docEl.setAttribute("font-size",rem + 'px'); flexible.rem = win.rem = rem;&#125;win.addEventListener('resize', function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 200);&#125;, false);win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 200); &#125;&#125;, false); 将设备宽度分为10份，而每一份视作一个单位，再将html的font-size设置为这个单位即： font-size = 750/10 = 75px； 1rem = 75px； 如果在宽度为750px的设备上，完全符合上述换算。如果在iphone6/7/8上，宽度为375，那么: font-size = 375/10 = 37.5px； 1rem = 37.5px； 现在以宽为750的设计稿为例，有一个款750px高75px的按钮 ；在iphone6/7/8上（实际宽375px）我们实际看到的宽高是多少呢？ width = 750/75 = 10rem —&gt; 10rem(在iphone6/7/8上) = 37.5px*10 = 375px； height = 75/75 = 1rem —&gt;1rem(在iphone6/7/8上) = 37.5px; 不难看出，只需要将这个单位作为除数即可计算出所需要的值； 六、打包工具开发完成之后使用hbuilder或cordova打包成为android APK或者ios IPA。我更偏向于cordova，插件相对更多，社区更加活跃，稳定的更新维护。当然，孰优孰劣各自体会。下文会具体介绍cordova的相关知识。 Hbuild：http://www.dcloud.io/ cordova：https://cordova.apache.org/ 七、UI框架开发框架常用的有ionic，mui，jQuery Mobile，weui等等。就事实而论，当设计稿给到开发者时，或者这些都用不到，全套UI自己写也是常见的。 八、angular、react还是vue？angular、react相对而言比较重，vue显得轻量一些，当开发大型SPA应用时，前两者是不错的选择，而vue完整的工具链以及活跃的社区也适应绝大部分的开发场景。 九、jQuery还用吗？对于事件的封装，DOM操作的实现都是毫无疑问需要使用的，同时集成的ajax封装也必不可少，不过不论是Web APP的开发还是 Hybrid App的开发，jq都是不二之选。但当我们在对请求过滤的处理时，这些get，post方法基本上不能满足我们的需求，所以需要对请求进行二次封装。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * 通用请求数据接口 * @param reqUrl * @param reqType * @param data * @param fn */ commonRequest: function commonRequest(reqUrl, reqType, data, fn) &#123; $.ajax(&#123; url: reqUrl, type: reqType, data: data, async: false, success: function success(data) &#123; fn(data); &#125;, error: function error(data) &#123; $.lightTip.error("网络请求错误-" + data.status, 2000); &#125; &#125;); &#125;, /** * 二次封装get请求 * @param reqUrl * @param data * @param fn */ get: function get(reqUrl, data, fn) &#123; $.ajax(&#123; url: reqUrl, type: 'GET', data: data, async: false, success: function success(data) &#123; if (data.meta.code === 200) &#123; fn(data); &#125; else &#123; alert(data.meta.message); throw new Error(data.meta.message); &#125; &#125;, error: function error(data) &#123; $.lightTip.error("网络请求错误-" + data.status, 2000); &#125; &#125;); &#125;, /** * 二次封装post请求 * @param reqUrl * @param data * @param fn */ post: function post(reqUrl, data, fn) &#123; $.ajax(&#123; url: reqUrl, type: 'POST', data: data, async: false, success: function success(data) &#123; if (data.meta.code === 200) &#123; fn(data); &#125; else &#123; alert(data.meta.message); throw new Error(data.meta.message); &#125; &#125;, error: function error(data) &#123; $.lightTip.error("网络请求错误-" + data.status, 2000); &#125; &#125;); &#125;, /** * formData上传数据 * @param reqUrl * @param reqType * @param data * @param fn */ formDataReq: function formDataReq(reqUrl, reqType, data, fn) &#123; $.ajax(&#123; url: reqUrl, data: data, type: reqType, processData: false, contentType: false, success: function success(data) &#123; if (data.meta.code === 200) &#123; fn(data); &#125; else &#123; alert(data.meta.message); throw new Error(data.meta.message); &#125; &#125;, error: function error(data) &#123; $.lightTip.error("网络请求错误-" + data.status, 2000); &#125; &#125;); &#125;, 这样封装一次，当用户没有登录时，可以根据返回的数据进行过滤处理。 当然如果你不用jq也可以选择其他的类库如封装ajax请求的axios！ 十、swiper是个好东西swiper常用于移动端网站的内容触摸滑动，是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端，Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效。这个插件功能确实强大，官网惊艳，api文档走心，性能不错。用作APP开发的主容器亦有一战之力。 十一、cordova开发详解1、cordova开发环境搭建，以android为例1、安装jdk（建议jdk8+），配置环境变量； 2、安装android sdk（至少到27，也可以安装android studio依赖安装），配置环境变量； 3、安装node（npm，也可以选择使用yarn）（node建议8+），如果不是默认安装，请配置环境变量； 4、安装bower，用以下载各种前端类库； 5、使用npm install -g cordova全局安装cordova，如果安装过慢或失败请科学上网； 2、创建一个app并运行起来1、cordova create \[文件夹名\] \[包名\] \[app名\] 1$ cordova create hello com.example.hello HelloWorld 2、添加平台（以android为例） 123$ cd hello$ cordova platform add android 3、build项目 123456789cordova build android...............BUILD SUCCESSFUL in 7s47 actionable tasks: 1 executed, 46 up-to-dateBuilt the following apk(s): D:\dev\****\****\****\platforms\android\app\build\outputs\apk\debug\app-debug.apk 在路径：\platforms\android\app\build\outputs\apk\debug\app-debug.apk下可以找到apk文件。 3、常用命令123456789101112Global Commands create ............................. 创建项目 help ............................... 获取帮助 telemetry .......................... 开启或关闭遥测采集 config ............................. 全局配置Project Commands info ............................... 项目基本信息 requirements ....................... 检查并打印出指定平台的所有要求 platform ........................... 管理项目平台 plugin ............................. 管理插件 compile ............................ 编译项目 clean .............................. 清除项目 更多命令可以到官网查看。 4、项目结构如果项目成功运行，您看到的项目结构应该如下： www文件夹作为开发主文件夹； res文件夹存放app的闪屏图片和icon； plugins文件夹存放插件； plaatforms文件夹存放诸如android、ios等各端的文件； node-modules文件夹自然是依赖的各个模块 config.xml是项目的配置文件，你添加的插件将会在里面显示，如状态栏插件，你可以添加更多插件。 1&lt;plugin name=&quot;cordova-plugin-statusbar&quot; spec=&quot;^2.4.2&quot; /&gt; 5、常用插件收集：phonegap-plugin-barcodescanner ： 二维码扫描 cordova-plugin-statusbar：状态栏 cordova-plugin-inappbrowser： 内置浏览 cordova-plugin-camera：照相机 插件太多可查看这里 官方的插件搜索地址点击这里 6、插件使用，以imagePicker为例子1cordova plugin add cordova-plugin-imagepicker 使用： 12345678910111213141516171819202122document.addEventListener("deviceready",onDeviceReady); function onDeviceReady()&#123; console.log("onDeviceReady"); $(document).on("tap","#getPictures",()=&gt;&#123; window.imagePicker.getPictures( function(results) &#123; for (let i = 0; i &lt; results.length; i++) &#123; console.log('Image URI: ' + results[i]); alert('Image URI: ' + results[i]); &#125; &#125;, function (error) &#123; console.log('Error: ' + error); alert('Error: ' + error); &#125;,&#123; maxImages: 9, width: 500, height: 500, quality:60 &#125; ); &#125;) &#125; 当然要实现QQ登录、微信登录等功能也是完全没有问题的，只需要添加对应的插件使用就可以了。 7、构建release版本以及签名构建release版本cordova build android –release 对 APK 签名jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore release-key.keystore platforms/android/build/outputs/apk/android-release-unsigned.apk [秘钥]apk签名的相关知识比较复杂，可以阅读这一篇：Cordova 打包 Android release app 过程详解]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[egret开发系列之scoller+list列表使用]]></title>
    <url>%2F20181122%2Fegret%2F</url>
    <content type="text"><![CDATA[一、概要1、egret项目需要使用到滑动列表，之前在网上找了很多文章，总的来说讲的七零八落，质量也不高，加之与egret相关的资料也少之又少，所以本废柴也研究了很久才总结下来，希望给有次相关需求的小萌新起到一丢丢引导！大佬还请自动飘过。 2、滑动列表是项目中常见的组件，比如装备列表，排行榜等都需要使用到，这里egret里面使用eui中Scroller+List实现。 二、实现效果预览 大概就是一个任务角色的滑动列表，点击换装，头顶有个绿色的字展示切换状态，滑动的时候，靠近中间的item需要渐进放大，远离中间的item需要渐进缩小（瓜皮策划提的需求，希望不要被看见！！ 虽然就是这么一个简单的效果，实现起来还是有一些复杂（策划：对啊，很简单啊！我：简单nmb！ 三、实现1、首先默认您知道exml的使用前提下，需要准备四个文件： SkinSelectPanel.exml –&gt;界面布局exml文件； ScrollerItem.exml –&gt;每一个小item的exml文件； SkinSelectPanel.ts –&gt;界面布局的逻辑处理ts文件； ScrollerItem.ts –&gt;每一个小item的逻辑处理ts文件； 2、exml布局文件与ts逻辑的关联 可以肯定的是，exml文件最重要的是每一个组件的命名，即右上角的ID，它将与ts里面定义的变量一一对应；记住List放在Scoller里面。 点击右侧的list，关于list的布局设置可以展示出来，比如VerticalLayout，Horizontalayout等布局方式、水平垂直间距、内边距等等属性都可以安装需求设置，当然在代码里面设置也是可以的。 SkinSelectPanel类需要继承eui.Component，构造器里需要实现super方法，并给skinName赋值。 定义的变量名与exml里组件的ID名相同这样就自动对应起来了。 此外，为了性能，特意写成单例。 123456789101112131415161718192021222324class SkinSelectPanel extends eui.Component&#123; private static instance; public skinBg:eui.Image; public scroller:eui.Scroller; public list : eui.List; public roles_component:eui.Group; public close_btn:eui.Image; public role :RoleDragonAni; public oxygen_label:eui.Label; public revival_label:eui.Label; public speed_label:eui.Label; public rolename_label:eui.Label; public des_label:eui.Label; private constructor() &#123; super(); this.skinName = "resource/eui_skins/SkinSelectPanel.exml"; &#125; static getInstance(): SkinSelectPanel &#123; return SkinSelectPanel.instance ? SkinSelectPanel.instance : SkinSelectPanel.instance = new SkinSelectPanel(); &#125;&#125; ScrollerItem类需要继承eui.ItemRenderer，另外有一个protected类型dataChanged()方法，此方法用于监听绑定在item上数据的变化情况。 123456789101112131415161718192021class ScrollerItem extends eui.ItemRenderer &#123; public rolename :eui.Label; public avatar:eui.Image; public bgi:eui.Image; public clothId:string; public isSelect:eui.Image; public dataManager:DataManager = DataManager.getInstance(); public skinSelectPanel:SkinSelectPanel = SkinSelectPanel.getInstance(); public socket:SocketUtils = SocketUtils.getInstance(); public constructor() &#123; super(); this.skinName =&quot;resource/eui_skins/ScrollerItem.exml&quot;; //this.data 这个data是在绑定数据的时候，赋到这个类上面的，稍后会用到 &#125; protected dataChanged():void&#123; //此处对this.data进行操作 &#125;&#125; 3、具体实现 SkinSelectPanel 继承了eui.Component有一个protected类型的createChildren()方法，主逻辑就写在这里面吧： 12345678910111213141516protected createChildren(): void &#123; super.createChildren(); //list是在exml中的组件List，它有dataProvider属性，负责提供数据列表源，这个数据列表必须是 //eui.ArrayCollection()的,这玩意有很多方法，如replaceAll()，可以点进源码去看，很简单不赘述。 this.list.dataProvider = this.dataArray; //itemRenderer 即渲染的item对象，这个就是我们的ScrollerItem类，这样赋值之后，每一个ScrollerItem上面 //都会绑定一个data对象，这个对象就是需要渲染的数据。 this.list.itemRenderer = ScrollerItem; this.dataArray.replaceAll(this.dataManager.skinList); this.list.addEventListener(eui.ItemTapEvent.ITEM_TAP, this.onItemTapHandler, this); this.scroller.addEventListener(egret.Event.CHANGE,this.moveScroller,this); this.close_btn.addEventListener(egret.TouchEvent.TOUCH_TAP,this.closePanel,this); this.roles_component.addEventListener(egret.TouchEvent.TOUCH_TAP,this.playAction,this); this.scroller.addEventListener(egret.Event.ADDED,this.initScale,this)&#125; 这样基本功能就实现完成，如果你有数据，并且代码没有问题，那么就可以看到简单的效果了，关于gif中缩放的效果，其实就是位置的不停判断： 这个你需要为scroller监听一个事件： 1this.scroller.addEventListener(egret.Event.ADDED,this.initScale,this) 123456789101112131415161718192021222324252627/** * 初始化item的缩放 */public initScale()&#123; let sc = this.scroller; if(sc.viewport.$children.length&gt;=5)&#123; for(let i = 0;i&lt;sc.viewport.$children.length;i++)&#123; let chaz = sc.height/2 -(sc.viewport.$children[i].y+sc.viewport.$children[i].height/2-sc.viewport.scrollV); if(Math.abs(chaz)&lt;200 &amp;&amp; Math.abs(chaz)&gt;0)&#123; if(chaz&lt;0)&#123; sc.viewport.$children[i].scaleY = 1.2+chaz/1000; sc.viewport.$children[i].scaleX = 1.2+chaz/1000; &#125;else if(chaz&gt;0)&#123; sc.viewport.$children[i].scaleY = 1.2-chaz/1000; sc.viewport.$children[i].scaleX = 1.2-chaz/1000; &#125; &#125;else if(Math.abs(chaz)==0)&#123; sc.viewport.$children[i].scaleX = 1.2; sc.viewport.$children[i].scaleY = 1.2 &#125;else&#123; sc.viewport.$children[i].scaleX = 1; sc.viewport.$children[i].scaleY = 1 &#125; &#125; this.scroller.removeEventListener(egret.Event.ADDED,this.initScale,this) &#125;&#125; 另外关于换装的，使用了龙骨动画，网络我使用了socket.io与服务器保持长连接，这些由于不属于本文的内容就不详细讲了。 四、结语关于源文件如果需要的请下方留言！ 如果有不懂的地方也可以方留言！ 如果需要了解其他相关知识的可以私信，可以做一笔jy！ 另外请各位大佬不要怼我 `(+﹏+)′]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[教室的那一间]]></title>
    <url>%2F20181026%2Fjsdnyj%2F</url>
    <content type="text"><![CDATA[昨天买了新手机，魅族16,8+128，真香。 其实老早就想换了，一直拖了很久，总算是实现了。 这个周并没有做太多事，浑浑噩噩，行尸走肉一般，加上有点感冒，上班也没有太好的状态。 这几天《教室的那一间》也很火，这部剧是在三中拍的，每个场景都很熟悉，除了一些演员的演技不是那么好，男主的台词语调确实不怎么样之外，总的来说，剧情还是很真实的，友情、爱情还有一点点师生情，想想自己离开高中已经四年了，如今大学毕业。但是看到那些剧情，以前经历过的事还是历历在目，打球吃饭上课玩游戏…恍然若梦。 每个班都有个胖子，有个瘦子，有娘娘腔，有女汉子，有学霸，有学渣，有小情侣，有暗恋别人的，有混子，有讨厌每一个老师的，有怎么学都学不好的学弱……]]></content>
      <categories>
        <category>记事簿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[再见，RNG]]></title>
    <url>%2F20181021%2Frng%2F</url>
    <content type="text"><![CDATA[我于杀戮之中盛放，亦如黎明中的花朵。 –戏命师今天EDG的比赛我没有看，因为不想再花时间在没有太多意义的事情上。 或许很多人都和我一样，在各种哀其不争的愤懑下，渐渐的失去了耐心。从去年四进二2：3不敌SKT，到今年拿下除了S赛的所有冠军，大家都以为要大满贯的时候，突然爆冷出局，令人心寒。所以我打算不再去期待了。 面向人群，为他们泣血哀鸣。 我的面容，就和杀你的人一样。 凭着我的技术，杀戮，也会绽放为艺术。 你…启发了我！ 你将知晓真正的美。 笑一个吧，大家都在看着呢。 成为我的作品，你将得以超脱。 此刻，大美将临。]]></content>
      <categories>
        <category>记事簿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[egret入门，这一篇应该够了]]></title>
    <url>%2F20180802%2Fegretlearn%2F</url>
    <content type="text"><![CDATA[下载安装：1、EgretLauncher传送门：https://egret.com/downloads/engine.html 下载完成按照要求一步步安装就可以了。 引擎管理工具，包括版本管理，项目打包，项目创建，其他工具下载安装等。 2、Egret Wing打开EgretLauncher引擎管理工具，下载安装egret wing，（这里需要账号密码登录，如果没有就去注册一个吧！ egret wing支持可视化创建、编辑和管理项目 EUI，以及 TS 代码编写和断点调试。 3、更多工具egret的工具非常多，上述安装的wing是最主要的开发工具，其余的安装方法也差不多，简单用法介绍可以参考官网的介绍，这里不赘述。 传送门：https://www.egret.com/products/ 项目创建1、项目类型打开EgretLauncher，选中项目，点击创建项目： 创建项目有两个选项，游戏项目和EUI项目，主要是勾选的拓展库不同，建议创建时不管是哪种，都将eui 和game两个库都勾选上。 除了默认勾选的，其他按需求勾选。 舞台尺寸一般按照美术出图设置。 2、缩放模式有很多种，具体介绍可以看官网介绍，可以说非常详细了 传送门 http://developer.egret.com/cn/github/egret-docs/Engine2D/screenAdaptation/zoomMode/index.html 旋转方式一般就横屏竖屏或者自动模式，最后创建项目。 目录结构打开创建的项目： .wing文件夹 存放使用wing打开的配置文件 bin-debug文件夹 存放调试时将ts转为js文件 bin-release文件夹 存放打包输出文件(打包后才会出现) libs文件夹 存放引擎源码以及三方库文件 resources文件夹 存放资源文件包括图片、json、动画、exml等文件 scripts文件夹 存放一些配置文件，比如android ios wxgame的配置脚本文件 src文件夹 存放开发源码 template文件夹 存放模板文件 egretProperties.json文件 三方库的配置文件 其他的可以不用管了，如果还需要详细了解的： 传送门：http://developer.egret.com/cn/github/egret-docs/Engine2D/getStarted/helloWorld/index.html 项目入口打开项目进入src文件目录 以下是我修改添加注释后的源码（Main.ts） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Main extends eui.UILayer &#123; protected createChildren(): void &#123; super.createChildren(); egret.lifecycle.addLifecycleListener((context) =&gt; &#123; // custom lifecycle plugin &#125;) //inject the custom material parser //注入自定义的素材解析器 let assetAdapter = new AssetAdapter(); egret.registerImplementation("eui.IAssetAdapter", assetAdapter); egret.registerImplementation("eui.IThemeAdapter", new ThemeAdapter()); this.runGame().catch(e =&gt; &#123; console.log(e); &#125;) &#125; private async runGame() &#123; await this.loadResource() //this.createGameScene(); const result = await RES.getResAsync("description_json") const gameui:GameUi = new GameUi(); this.stage.addChild(gameui) &#125; //资源加载函数， private async loadResource() &#123; try &#123; //加载页面添加到舞台 const loadingView = new LoadingUI(); this.stage.addChild(loadingView); //加载默认资源，json文件，里面记录着所有的图片数据 await RES.loadConfig("resource/default.res.json", "resource/"); //加载皮肤文件 await this.loadTheme(); //加载资源组 await RES.loadGroup("preload", 0, loadingView); //加载完成后将加载页面从舞台移除 this.stage.removeChild(loadingView); console.log('资源加载完成') &#125; catch (e) &#123; console.error(e); &#125; &#125; private loadTheme() &#123; return new Promise((resolve, reject) =&gt; &#123; //加载皮肤主题配置文件,可以手动修改这个文件。替换默认皮肤。 let theme = new eui.Theme("resource/default.thm.json", this.stage); theme.addEventListener(eui.UIEvent.COMPLETE, () =&gt; &#123; resolve(); &#125;, this); &#125;) &#125; private textfield: egret.TextField; /** * 创建游戏场景 * Create a game scene */ private createGameScene() &#123; let sky = this.createBitmapByName("dabg@3x_png"); this.addChild(sky); let stageW = this.stage.stageWidth; let stageH = this.stage.stageHeight; sky.width = stageW; sky.height = stageH; &#125; /** * 根据name关键字创建一个Bitmap对象。name属性请参考resources/resource.json配置文件的内容。 * Create a Bitmap object according to name keyword.As for the property of name please refer to the configuration file of resources/resource.json. */ private createBitmapByName(name: string) &#123; let result = new egret.Bitmap(); let texture: egret.Texture = RES.getRes(name); result.texture = texture; return result; &#125; /** * 描述文件加载成功，开始播放动画 * Description file loading is successful, start to play the animation */ private startAnimation(result: string[]) &#123; let parser = new egret.HtmlTextParser(); let textflowArr = result.map(text =&gt; parser.parse(text)); let textfield = this.textfield; let count = -1; let change = () =&gt; &#123; count++; if (count &gt;= textflowArr.length) &#123; count = 0; &#125; let textFlow = textflowArr[count]; // 切换描述内容 // Switch to described content textfield.textFlow = textFlow; let tw = egret.Tween.get(textfield); tw.to(&#123; "alpha": 1 &#125;, 200); tw.wait(2000); tw.to(&#123; "alpha": 0 &#125;, 200); tw.call(change, this); &#125;; change(); &#125;&#125; 资源适配器（AssetAdapter .ts） 1234567891011121314151617181920212223242526class AssetAdapter implements eui.IAssetAdapter &#123; /** * @language zh_CN * 解析素材 * @param source 待解析的新素材标识符 * @param compFunc 解析完成回调函数，示例：callBack(content:any,source:string):void; * @param thisObject callBack的 this 引用 */ public getAsset(source: string, compFunc:Function, thisObject: any): void &#123; function onGetRes(data: any): void &#123; compFunc.call(thisObject, data, source); &#125; if (RES.hasRes(source)) &#123; let data = RES.getRes(source); if (data) &#123; onGetRes(data); &#125; else &#123; RES.getResAsync(source, onGetRes, this); &#125; &#125; else &#123; RES.getResByUrl(source, onGetRes, this, RES.ResourceItem.TYPE_IMAGE); &#125; &#125;&#125; 主题适配器（ThemeAdapter.ts） 12345678910111213141516171819202122232425262728293031323334class ThemeAdapter implements eui.IThemeAdapter &#123; /** * 解析主题 * @param url 待解析的主题url * @param onSuccess 解析完成回调函数，示例：compFunc(e:egret.Event):void; * @param onError 解析失败回调函数，示例：errorFunc():void; * @param thisObject 回调的this引用 */ public getTheme(url: string, onSuccess: Function, onError: Function, thisObject: any): void &#123; function onResGet(e: string): void &#123; onSuccess.call(thisObject, e); &#125; function onResError(e: RES.ResourceEvent): void &#123; if (e.resItem.url == url) &#123; RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onResError, null); onError.call(thisObject); &#125; &#125; if (typeof generateEUI !== 'undefined') &#123; egret.callLater(() =&gt; &#123; onSuccess.call(thisObject, generateEUI); &#125;, this); &#125; else &#123; RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onResError, null); RES.getResByUrl(url, onResGet, this, RES.ResourceItem.TYPE_TEXT); &#125; &#125;&#125;declare var generateEUI: &#123; paths: string[], skins: any &#125; 关于js的异步，依然使用了es7的async与await，用法自行脑补 关于三方库引入打开egretProperties.json 按照已有的格式以相同的写法将你的三方库路径添加上去，然后在终端执行egret build -e命令 以引入socket.io为例： 开发根目录：D:\dev\live-psz socket.io目录：D:\dev\socket-libsrc 1234&#123; "name": "socket.io", "path": "../socket-libsrc/bin/socket.io"&#125; 关于exml主题UI布局在resource目录下新建eui_skins文件夹，在下面新建**.exml文件，然后进行布局， 在default.thm.json确保引入 12345678910111213&#123; "skins": &#123;&#125;, "autoGenerateExmlsList": true, "exmls": [ "resource/eui_skins/Animation.exml", "resource/eui_skins/AniShowCName.exml", "resource/eui_skins/GameUi.exml", "resource/eui_skins/RoleDetailUi.exml", "resource/eui_skins/RoleUi.exml", "resource/eui_skins/test.exml" ], "path": "resource/default.thm.json"&#125; 在src下面新建对应的ts文件 1class GameUi extends eui.Component 1234constructor() &#123; super(); this.skinName = "resource/eui_skins/GameUi.exml";&#125; 如果在布局里面命名了相对应的Id，那么 12public gold_group_btn :eui.Group;public roleContainer: eui.Group; 如何引用 12const gameui:GameUi = new GameUi();this.stage.addChild(gameui) 最后其他涉及到的API可以查看官网文档，如有错误，望斧正，如有疑问，请留言，我会及时回复。]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laya核心API五分钟速记]]></title>
    <url>%2F20180721%2Flaya-api%2F</url>
    <content type="text"><![CDATA[Node(节点)操作大部分的laya UI组件都可以看做节点，可以看做web开发中，使用JavaScript对html节点进行操作。添加节点核心方法： 1234567891011121314151617181920212223/** * 添加子节点。 * @param node 节点对象 * @return 返回添加的节点 */addChild(node: Node): Node;/** * 批量增加子节点 * @param ...args 无数子节点。 */addChildren(...args: any[]): void;/** * 添加子节点到指定的索引位置。 * @param node 节点对象。 * @param index 索引位置。 * @return 返回添加的节点。 */addChildAt(node: Node, index: number): Node;/** * 根据子节点对象，获取子节点的索引位置。 * @param node 子节点。 * @return 子节点所在的索引位置。 */ 注意：添加节点时候，越后添加的层级越高，可以设置zOrder属性调整对象层级。 销毁、删除节点核心方法： 123456789101112131415161718192021222324252627282930/** * 删除子节点。 * @param node 子节点 * @return 被删除的节点 */removeChild(node: Node): Node;/** * 从父容器删除自己，如已经被删除不会抛出异常。 * @return 当前节点（ Node ）对象。 */removeSelf(): Node;/** * 根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。 * @param name 对象名字。 * @return 查找到的节点（ Node ）对象。 */removeChildByName(name: string): Node;/** * 根据子节点索引位置，删除对应的子节点对象。 * @param index 节点索引位置。 * @return 被删除的节点。 */removeChildAt(index: number): Node;/** * 删除指定索引区间的所有子对象。 * @param beginIndex 开始索引。 * @param endIndex 结束索引。 * @return 当前节点对象。 */removeChildren(beginIndex?: number, endIndex?: number): Node; 12345678910/** * &lt;p&gt;销毁此对象。destroy对象默认会把自己从父节点移除，并且清理自身引用关系，等待js自动垃圾回收机制回收。destroy后不能再使用。&lt;/p&gt; * &lt;p&gt;destroy时会移除自身的事情监听，自身的timer监听，移除子对象及从父节点移除自己。&lt;/p&gt; * @param destroyChild （可选）是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。 */destroy(destroyChild?: boolean): void;/** * 销毁所有子对象，不销毁自己本身。 */destroyChildren(): void; 注意：如果将节点销毁，则不能再使用，但删除之后的节点依旧可以使用。 获取节点核心方法： 123456789101112/** * 根据子节点对象，获取子节点的索引位置。 * @param node 子节点。 * @return 子节点所在的索引位置。 */getChildIndex(node: Node): number;/** * 根据子节点的名字，获取子节点对象。 * @param name 子节点的名字。 * @return 节点对象。 */getChildByName(name: string): Node; 注意：getChildByName方法传入的name，是在创建的时候为节点设置的name，并且只能获取下一级的孩子节点，而不是所有属于当前节点的所有子节点。 事件事件类型非常多，常用的有： 12345678910111213141516/** 定义 mousedown 事件对象的 type 属性值。*/static MOUSE_DOWN: string;/** 定义 mouseup 事件对象的 type 属性值。*/static MOUSE_UP: string;/** 定义 click 事件对象的 type 属性值。*/static CLICK: string;/** 定义 rightmousedown 事件对象的 type 属性值。*/static RIGHT_MOUSE_DOWN: string;/** 定义 rightmouseup 事件对象的 type 属性值。*/static RIGHT_MOUSE_UP: string;/** 定义 rightclick 事件对象的 type 属性值。*/static RIGHT_CLICK: string;/** 定义 mousemove 事件对象的 type 属性值。*/static MOUSE_MOVE: string;/** 定义 mouseover 事件对象的 type 属性值。*/static MOUSE_OVER: string; 具体可以查看layaAir.d.ts laya.events模块，大概在17316行……. 事件绑定： 1234567891011121314151617181920 /** * &lt;p&gt;增加事件侦听器，以使侦听器能够接收事件通知。&lt;/p&gt; * &lt;p&gt;如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。&lt;/p&gt; * @param type 事件的类型。 * @param caller 事件侦听函数的执行域。 * @param listener 事件侦听函数。 * @param args （可选）事件侦听函数的回调参数。 * @return 此 EventDispatcher 对象。 */on(type: string, caller: any, listener: Function, args?: Array&lt;any&gt;): EventDispatcher;/** * &lt;p&gt;增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。&lt;/p&gt; * &lt;p&gt;如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。&lt;/p&gt; * @param type 事件的类型。 * @param caller 事件侦听函数的执行域。 * @param listener 事件侦听函数。 * @param args （可选）事件侦听函数的回调参数。 * @return 此 EventDispatcher 对象。 */once(type: string, caller: any, listener: Function, args?: Array&lt;any&gt;): EventDispatcher; 注意：多次为同一个节点使用on方法会多次绑定事件，需要了解的是，如果对节点的操作不会有变化，则使用on方法绑定一次即可，如果根据状态条件等因素的不同，则使用once绑定。 网络网络请求也是封装的HttpRequest，比较简单。 123456789 /** * 发送 HTTP 请求。 * @param url 请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。 * @param data (default = null)发送的数据。 * @param method (default = "get")用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。 * @param responseType (default = "text")Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。 * @param headers (default = null) HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如["Content-Type", "application/json"]。 */send(url: string, data?: any, method?: string, responseType?: string, headers?: Array&lt;any&gt;): void; 一个简单的请求网络数据示例： 12345678910111213141516171819202122getList(page,size,url)&#123; let http = new Laya.HttpRequest(); http.send(`$&#123;this.gd.host&#125;$&#123;url&#125;?userId=$&#123;this.gd.user.id&#125;&amp;page=$&#123;page&#125;&amp;size=$&#123;size&#125;`, 'GET'); http.timeout = 1000; return new Promise((resolve, reject) =&gt; &#123; http.once(Laya.Event.COMPLETE, this, (resp) =&gt; &#123; resp = JSON.parse(resp); if (resp.meta.code === 200) &#123; if (resp.data !== null) &#123; resolve(resp.data) &#125; else &#123; resolve(resp.data); &#125; &#125; else &#123; console.log('服务器错误'); &#125; &#125;); http.once(Laya.Event.ERROR, this, (resp) =&gt; &#123; resolve(resp.data); &#125;); &#125;) &#125; 1let data = await EventUtils.getInstance().getList(this.currentPage, this.size,'/norain/pre/rank/time');//请求加载数据 动画缓动动画 缓动类型解释传送门：https://layaair.ldc.layabox.com/api/?category=Core&amp;class=laya.utils.Ease 缓动动画演示传送门：https://layaair.ldc.layabox.com/demo/?category=2d&amp;group=Tween&amp;name=EaseFunctionsDemo]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laya入门，这一篇应该够了]]></title>
    <url>%2F20180712%2Flaya%2F</url>
    <content type="text"><![CDATA[简述LayaAir 是基于HTML5开源引擎，所开发的游戏既可以网页运行，也可以打包Android &amp; ios app运行，目前更到1.7.19.1 beta版本，本次使用1.7.18稳定版。 本文介绍laya的下载安装，项目创建，目录结构，环境配置与es6+的支持，及具体开发知识，网页端发布等等方面。 下载安装官网传送门：www.layabox.com 进入首页看到如下两个下载按钮： 此刻就让人有点懵逼了，layaAir Engine可以理解为引擎内核（源码），IDE就是集成开发工具了，直接下载IDE就好，因为下载下来的已经集成对应版本的源码包了（你会发现，每一个版本的源码都有对应版本的IDE。截止目前更到1.7.19.1 beta版本，为了稳定还是使用1.7.18版本。如下（对，你没看错，蓝色那个，点…点…点它： 下载完成之后是一个zip压缩包，不用安装的，直接解压到你想放的位置，完事儿之后就可以使用了： 就是他了（.exe文件，双击吧，看到如下界面你就完成第一步了！ 项目创建与目录结构点击新建项目，弹出如下框： 选择默认的UI示例项目，类型选择JavaScript项目，如果你会as或者ts也可以选它，然后点击创建，创建完成进入代码模式，简单标注了一下： 接下来什么将调试器选择chrome调试，点击三角按钮或者按f5运行，你会看到如下一个巨丑的页面弹出来emmmm（真的很丑，但是只要正常看到，这一步就算完成了）。 接下来是目录结构，传送门：https://ldc.layabox.com/doc/?nav=zh-js-1-0-0，不过这个里面说的hin多hin杂，在这里简单说重点： 项目运行配置文件（.laya文件夹）。 launch.json，当你将项目移动或拷贝到别处的时候需要修改，什么路径统统要改。 如果你用chrome运行项目，会有一个chrome文件夹，不用管他，垃圾东西。 项目的输出目录（bin文件夹）。项目编译后的东西都在里面，什么动画，图集，你的源码等等，最后项目发布也是从这个目录发布 lib，全是引擎的源码包，不用的可以删除 res，资源文件，图片图集，音频文件都可以在里面 index.html，点进去看看，里面说的很清楚了 UI项目目录（laya）。其实这些都看自己的喜好，没有规定的话，只要合理爱咋咋地吧。 laya/assets目录用来存放UI页面、粒子等组件所需的图片资源。 laya/pages目录用来存放LayaAirIDE创建页面布局生成的文件。 代码提供文件目录（libs），不用管他。 项目代码目录（src）。 这个就比较牛逼了，全是你的代码，不过后面我们不在里面开发。 目录结构也介绍完了，这一节大概就是这些，下一节讲解配置我们真正的而开发环境。 环境配置既然是属于h5前端开发，自然要配置一系列的工具。webpack，babel，gulp等等。（如果大家不想使用这些工具，直接用项目默认的开发模式也可以，前面也足够了） 安装Node.js，推荐稳定版本8.x吧（不会问度娘。 在项目根目录新建文件夹www（其实开发文件夹应该叫做src的，无奈被默认的目录占用了，src这个文件夹不能动他，因为构建的ui文件类会在里面，稍后我们输出webpack的main.js也会放在里面。然后项目编译时会用到src）。 接下来切换到下方的终端（没有看到的话f5一下吧），用npm安装如下一堆依赖的东西（你可以直接建一个package.json文件，将下面的考进去，然后npm install，谢谢赶紧我~~）。完了之后www会有一个node_modules文件夹，全是刚才装的b： 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;webpack&quot;: &quot;webpack&quot; &#125;, &quot;author&quot;: &quot;wxq&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;, &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;dateformat&quot;: &quot;^3.0.3&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-babel&quot;: &quot;^7.0.1&quot;, &quot;gulp-less&quot;: &quot;^3.4.0&quot;, &quot;gulp-util&quot;: &quot;^3.0.8&quot;, &quot;webpack&quot;: &quot;^3.10.0&quot;, &quot;webpack-stream&quot;: &quot;^4.0.0&quot; &#125;&#125; 创建.babelrc文件，里面是babel的预设集配置等，如果你不想懂，可以直接copy进去： 123456789101112&#123; &quot;presets&quot;: [&quot;env&quot;], &quot;plugins&quot;: [[ &quot;transform-runtime&quot;, &#123; &quot;helpers&quot;: false, &quot;polyfill&quot;: false, &quot;regenerator&quot;: true, &quot;moduleName&quot;: &quot;babel-runtime&quot; &#125; ]]&#125; 创建webpack.config.js文件，这个是webpack的配置文件，主要配置webpack打包的入口文件口和输出文件，之后会时候gulp的自动任务执行webpack打包，同时会将es6（es7、es8）通过bable转译为es5。 创建gulpfile.js文件，这个是gulp的配置文件，如果你不想懂，也可以直接copy进去： 123456789101112131415const gulp = require("gulp");//转译JavaScriptgulp.task("webpack",()=&gt;&#123; const webpack = require("webpack-stream"); const config = require("./webpack.config"); gulp.src("./src/**/*.js") .pipe(webpack(config)) .pipe(gulp.dest("../src/"))&#125;);gulp.task("watch",function()&#123; gulp.watch("./src/**/*.js",['webpack']);&#125;);gulp.task("default",["webpack",'watch']); 解释一下吧，引入依赖gulp，创建三个任务，第一个是打包任务，webpack执行，第二个是watch任务监听文件变化自动执行第一个任务，这样就不需要每次修改文件都去执行gulp命令了，美滋滋~~，第三个默认任务，就是去执行上面两个咯。 执行npm install gulp -g 安装gulp到全局（必须安装到全局 全局 -g），不然会报错。 上述步骤完成且没有问题之后，成功之后再去执行gulp命令吧，如图我将www下面的src文件夹下面的所有东西都打包到了根目录下的src文件夹的mian.js文件里面: 然后打开你的www–&gt;src–&gt;main.js： 就长这样啦，然后去把index.html里面的代码改改吧，噢啦，环境搭建完成。 12345&lt;!--IDE生成的UI文件--&gt; &lt;script src="../src/ui/layaUI.max.all.js"&gt;&lt;/script&gt; &lt;!--jsfile--startTag--&gt; &lt;script src="../src/main.js"&gt;&lt;/script&gt; &lt;!--jsfile--endTag--&gt; 如果到这里，你没有如遇到什么难题，那我们就可以准备进入正题了，emmmm。 开发入门舞台搭建与适配开发目录下新建的main.js文件全部代码删除，然后不用管它，接下来： GameMain.js: 12345678910111213141516171819export class GameMain &#123; constructor() &#123; &#125; static init() &#123; Laya.MiniAdpter.init(); Laya.init(768, 1366, Laya.WebGL); Laya.stage.bgColor = "#5a7b9a"; //水平对齐方式，水平居中 Laya.stage.alignH = Laya.Stage.ALIGN_CENTER; //垂直对齐方式，垂直居中 Laya.stage.alignV = Laya.Stage.ALIGN_MIDDLE; //按照宽度 Laya.stage.scaleMode = Laya.Stage.SCALE_SHOWALL; //屏幕适配，横屏还是竖屏，默认不改变 Laya.stage.screenMode = Laya.Stage.SCREEN_NONE; //禁用多点触控 Laya.MouseManager.multiTouchEnabled = false; &#125;&#125; 如果es6不懂的可以先去补一下，创建一个静态的方法init()。 Laya.MiniAdpter.init();//如果不考虑微信小游戏可以不加，当然加上也不会怎样。 Laya.init(768, 1366, Laya.WebGL);//初始化舞台大小，记住这个尺寸是设计大佬给的，她们的图都按照这个尺寸来做的。宽、高、渲染方式。 Laya.stage.bgColor = “#5a7b9a”;//这个舞台背景，爱咋咋地吧。 接下来的全是做是配的，copy贴上去就对了。还有其他的适配方式，以及参数，自己去官网看吧，反正我怎么不用。 关于图集打包与资源加载策略在进入main文件之前讲一讲这两点：图集打包与资源加载。 图集打包： 进入编辑模式，你懂我意思吧： 看图的时候不要问我拿来那么多文件，看重点：在这个界面，当你按下f12的时候，会发布代码，并将红色框里的文件夹里面的图片，按分文夹的方式打包成图集，这些文件就是在www/laya/assets下面，发布完成之后，你在bin/res/atlas下面看到图集的.png与.atlas（json）文件，这两个文件都是一一对应的。 注意：在编辑模式按f9可以进行设置，包括图集的大小，当然，这里主要也是设置图集大小。 这图集打包就这样咯，接下来是资源加载↓↓↓↓↓ 资源加载： 关于资源加载如果做过游戏都知道，有一个载入界面，载入界面用到的所有资源最好是放在游戏包里面，进行第一次加载。第一次加载完成之后就是加载游戏需要的其它大部分资源，这里面的资源有可能是在本地，也有可能加载网络资源，一般需要写一个资源加载类。 简单介绍laya里面的资源加载类该如何写： 主要使用Laya.loader.load()方法进行加载，该方法有三个参数： 1Laya.loader.load(this.resources, Laya.Handler.create(this, loaded), Laya.Handler.create(this, loading, null, false)); 第一个，资源，如果单个加载，可以写字符串路径，如果批量加载，写成数组对象： 12345678910111213141516171819let res = [ &#123;url: "res/atlas/start.atlas"&#125;, &#123;url: "res/atlas/activity.atlas"&#125;, &#123;url: "res/atlas/popup.atlas"&#125;, &#123;url: "res/atlas/comp.atlas"&#125;, &#123;url: "res/atlas/part.atlas"&#125;, &#123;url: "res/atlas/shareMask.atlas"&#125;, &#123;url: "res/atlas/common.atlas"&#125;, &#123; url: "res/sound/btn_click.mp3", name: "btn_click", type: Laya.Loader.SOUND &#125;, &#123; url: "res/sound/btnShowSound.mp3", name: "btnShowSound", type: Laya.Loader.SOUND &#125;] name可以作为名字调用资源，如果不写，用的时候只能通过字符串路径调用资源； type是资源类型，也可以不写，但最好写上 第二个：加载完成的回调，只返回true或者false， 第三个：加载过程的回调，返回的是数字，从0-100。 上一下完整的代码： 12345678910111213141516171819202122232425262728293031323334353637import &#123;GameMain&#125; from './base/GameMain.js'import &#123;ResLoader&#125; from './utils/ResLoader.js'import &#123;MainBoard&#125; from "./base/MainBoard";import &#123;UserUtils&#125; from "./utils/UserUtils";import &#123;GlobalData&#125; from "./base/GlobalData";import &#123;GameEvent&#125; from "./utils/GameEvent";import &#123;LayoutUtils&#125; from "./utils/LayoutUtils";GameMain.init();Laya.loader.load("res/atlas/loading.atlas", Laya.Handler.create(this, function (e) &#123; let resManager = ResLoader.getInstance(); let loading = new ui.view.gameLoadingUI(); Laya.stage.addChild(loading); let sp_mask = loading.sp_mask; sp_mask.optimizeScrollRect = true; resManager.loaded((e) =&gt; &#123; let mainBoard = MainBoard.getInstance(); let user = UserUtils.getInstance(); user.getWxUser(&#123; sucFn: () =&gt; &#123; console.log('登陆成功v1.0.0'); Laya.stage.addChild(LayoutUtils.getInstance().map.get("gameStartUI")); Laya.stage.removeChild(loading); mainBoard.initMainBoard(); GameEvent.getInstance().bindListenEvent(); GameEvent.getInstance().remarkGameTime(); &#125;, errFn: () =&gt; &#123; alert('登陆失败'); &#125; &#125;); &#125;, (e) =&gt; &#123; let process = parseInt(e * 100); loading.progress_text.text = process + '%'; sp_mask.scrollRect = new Laya.Rectangle(0, 0, 5.2 * process, 24); &#125;);&#125;)); resManager是我自己写的资源加载管理器，做统一资源管理，其实跟这加载一样，只是资源多，封装了一下。 多说一句：单例模式 因为这里基于es6的类，常常需要实例化类，像资源加载这种只需要实例化一次的就需要用到js的单例模式，具体实现如下： 12345678export class ResLoader &#123; static getInstance() &#123; return ResLoader.instance ? ResLoader.instance : ResLoader.instance = new ResLoader(); &#125; constructor() &#123;&#125;&#125; UI创建 如果你不想通过它的编辑器创建界面也是可以的，只不过全部用代码来实现比较麻烦，看看他的ui有哪些组件吧，传送门：https://layaair.ldc.layabox.com/api/?category=UI&amp;class=laya.ui.AsynDialog 什么Image，Text，Button，Sprite全部自己写也很不爽。不过你可以试试用自己写代码的方式来进行游戏布局，比如我写的一些： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758diyPopup(btnImgs) &#123; let length = btnImgs.length; let btnArr=[]; let popupUI = this.map.get('gamePopupUI'); for (let i = 0; i &lt; 3; i++) &#123; popupUI.removeChildByName(`btn$&#123;i===0?'':i&#125;`) &#125; if (length === 1) &#123; let btn = new Laya.Image().size(262, 116).pos(250, 678); btn.skin = btnImgs[0]; btn.name = 'btn'; btnArr.push(btn); popupUI.addChild(btn); &#125; else if (length === 2) &#123; let btn1 = new Laya.Image().size(262, 116).pos(67, 678); btn1.name = 'btn1'; btn1.skin = btnImgs[0]; let btn2 = new Laya.Image().size(262, 116).pos(443, 678); btn2.name = 'btn2'; btn2.skin = btnImgs[1]; btnArr.push(btn1,btn2); popupUI.addChild(btn1); popupUI.addChild(btn2); &#125; //遮罩 popupUI.bg_wrap.graphics.clear(); popupUI.bg_wrap.graphics.drawRect(0, 0, Laya.stage.width, Laya.stage.height, "#000000"); return &#123;popupUI:popupUI,btnArr:btnArr&#125; &#125; //自定义 diyIcon(iconArr) &#123; let length = iconArr.length; let mainUI = this.map.get('gameMainUI'); mainUI.icon_wrap.destroyChildren(); let iconUI = []; if (length === 1) &#123; let icon = new Laya.Image().size(77, 68).pos(258, 0); icon.skin = iconArr[0]; mainUI.icon_wrap.addChild(icon); iconUI.push(icon) &#125; else if (length === 2) &#123; for (let i = 0;i &lt; length;i++)&#123; let icon = new Laya.Image().size(77, 68).pos(207+i*(30+77), 0); icon.skin = iconArr[i]; mainUI.icon_wrap.addChild(icon); iconUI.push(icon) &#125; &#125; else &#123; for (let i = 0;i &lt; length;i++)&#123; let icon = new Laya.Image().size(77, 68).pos(169+i*(15+77), 0); icon.skin = iconArr[i]; mainUI.icon_wrap.addChild(icon); iconUI.push(icon) &#125; &#125; return iconUI; &#125; 还是用编辑器拖拖拉拉舒服，点击view新建页面/场景，最好把逻辑类勾，本人当时没有勾上，就全部发布到一个文件里面去了，下面会说的。然后直接往上怼： 做完之后按f12发布，就会发布到src/ui下面的layaUI.max.all.js里面。 接下来在代码里面引用： 12let gameMain= new ui.view.gameMainUI();Laya.stage.addChild(gameMain);//添加到舞台，removeChild()你懂吧 如此，页面场景也可以自己搭建好了。其实还有一部分是粒子和动画，但是我觉得这个可以看看官网给的教程（我司有做粒子和动画的，我不会），传送门：https://ldc.layabox.com/doc/?nav=zh-js-2-1-10。 这一入门部分也就告一段落，基本上可自己写出一个demo。下一篇准备讲讲使用laya的API以及其中遇到的巨坑。laya系列完了之后准备再写一个egret入门与坑的系列。如果有错误的地方，还请多多指教。]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node+express使用multiparty实现文件上传]]></title>
    <url>%2F20160520%2Fnode-express-fileupload%2F</url>
    <content type="text"><![CDATA[文件上传在一个项目中是相对于比较基础的功能，今天分享一下自己是如何在nodejs中使用中间件multiparty实现文件上传的。nodejs环境的搭建就不赘述了，直奔主题吧！ 第一步：引入express等需要用到的模块express，jade等模块都需要自己手动使用npm命令在控制台安装，如npm install express。在这里用的是jade模板引擎。 （文件 demo.js） 12345678910111213141516171819202122var express = require("express");//导入express模块var path = require('path');//路径配置模块var bodyParser = require('body-parser')//页面传递参数解析var mysql = require('mysql');//mysql模块var multiparty = require('multiparty');//文件上传模块var util = require('util');var fs = require('fs');var app = express(); var port = 3000;//端口号app.set("views","views/pages/");//设置视图文件路径app.set("view engine","jade");//设置模板引擎app.use(express.static(path.join(__dirname,'bower_components')))//设置静态文件路径app.use(bodyParser.urlencoded(&#123;extended: true,&#125;))app.listen(port);//监听端口console.log("start..."+port);console.log('连接开始');app.get("/index",function (req,res) &#123; res.send("hello")&#125;) 然后我们就可以在控制台启动服务 node demo，访问路径http://localhost:3000/index就可以看到结果了 开始编写html代码(因为使用的jade模板引擎，所以按照jade语法编写)主要是表单提交，关于样式代码就不解释了。代码和浏览器效果如下，其中代码有几个地方要解释一下,enctype=”multipart/form-data”这一段代码必须要加上，用于表单里图片上传，action = “/demo”代表表单提交处理的路径。并把后台的get 请求代码附上 （文件demo.jade） 12345678910111213141516171819div.con form.loginForm(method = &quot;post&quot;,enctype=&quot;multipart/form-data&quot; ,action = &apos;/demo&apos;) div.upload span 姓名: input.stuMsg.stu_name(type = &quot;text&quot;,name = &quot;name&quot;,placeholder = &quot;姓名&quot;) div.upload span 学号: input.stuMsg.stu_number(type = &quot;text&quot;,name = &quot;number&quot;,placeholder = &quot;学号&quot;) div.upload span 性别: input.stuMsg.stu_sex(type = &quot;text&quot;,name = &quot;sex&quot;,placeholder = &quot;性别&quot;) div.upload span 年龄: input.stuMsg.stu_age(type = &quot;text&quot;,name = &quot;age&quot;,placeholder = &quot;年龄&quot;) div.upload#containimg span 头像: input.stuMsg.stu_img(type = &quot;file&quot;,name = &quot;upfiles&quot;,multiple=&apos;mutiple&apos;) div.upload input.stuMsg.addmsg(type = &quot;submit&quot;,value = &quot;录入&quot;) （文件app.js） 123app.get("/demo",function (req,res) &#123; res.render('demo',&#123;&#125;)&#125;) 接着开始连接数据库，我使用的市mysql，同样需要引入模块。数据库里面的字段有id name number sex age img （文件demo.js） 12345678//创建连接数据库var conn = mysql.createConnection(&#123; host: 'localhost', user: 'root', database:'stu_manage_system', port: 3306,&#125;);conn.connect();//连接数据库 然后开始编写文件上传的核心代码： （文件demo.js） 123456789101112131415161718192021222324252627282930313233343536373839app.post("/demo",function(req,res)&#123; var insertSQL = 'insert into student values(0,?,?,?,?,?)'; var insertSQL_params = []; var form = new multiparty.Form();//实例一个multiparty form.uploadDir = __dirname+"/bower_components/uploads/";//设置文件储存路径 //开始解析前台传过来的文件 form.parse(req, function(err, fields, files) &#123; for (var item in fields)&#123; insertSQL_params.push(fields[item][0]) console.log(fields[item][0]) &#125; var filesTmp = JSON.stringify(files); var pr = JSON.parse(filesTmp) console.log(pr.upfiles.length) if(err)&#123; console.log('parse error: ' + err); &#125; else &#123; for (var i = 0 ; i &lt; pr.upfiles.length ; i++) &#123; var inputFile = files.upfiles[i];//获取第一个文件 var finalname = inputFile.originalFilename; insertSQL_params.push(finalname) var new_name =__dirname+"/bower_components/uploads/"+finalname;//获取文件名 console.log(new_name) var old_name = inputFile.path;//获取文件路径 console.log(old_name) fs.renameSync(old_name,new_name); &#125; &#125; //添加数据到数据库 conn.query(insertSQL,insertSQL_params, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log("成功") &#125; &#125;) res.send("成功") &#125;)&#125;) 其中有些地方解释一下： 首先实例一个multiparty赋给form， form.parse(req，callback)的回调函数三个参数，其中fields是一个对象，表示表单中非文件的数据 files参数也是一个对象，他包含了文件的所有信息 JSON.parse用于从一个字符串中解析出json对象JSON.stringify则相反 通过originalFilename获取文件的原始名，最后将文件信息存到数据库。 demo.jsd的完整代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var express = require("express");//导入express模块var path = require('path');//路径配置模块var bodyParser = require('body-parser')//页面传递参数解析var mysql = require('mysql');//mysql模块var multiparty = require('multiparty');//文件上传模块var util = require('util');var fs = require('fs');var app = express(); var port = 3000;//端口号app.set("views","views/pages/");//设置视图文件路径app.set("view engine","jade");//设置模板引擎app.use(express.static(path.join(__dirname,'bower_components')))//设置静态文件路径app.use(bodyParser.urlencoded(&#123;extended: true,&#125;))app.listen(port);//监听端口console.log("start..."+port);console.log('连接开始');//创建连接数据库var conn = mysql.createConnection(&#123; host: 'localhost', user: 'root', database:'stu_manage_system', port: 3306,&#125;);conn.connect();//连接数据库 app.get("/demo",function (req,res) &#123; res.render('demo',&#123;&#125;)&#125;)app.post("/demo",function(req,res)&#123; var insertSQL = 'insert into student values(0,?,?,?,?,?)'; var insertSQL_params = []; var form = new multiparty.Form();//实例一个multiparty form.uploadDir = __dirname+"/bower_components/uploads/";//设置文件储存路径 //开始解析前台传过来的文件 form.parse(req, function(err, fields, files) &#123; console.log(fields) for (var item in fields)&#123; insertSQL_params.push(fields[item][0]) console.log(fields[item][0]) &#125; console.log(files) var filesTmp = JSON.stringify(files); var pr = JSON.parse(filesTmp) console.log(pr.upfiles.length) if(err)&#123; console.log('parse error: ' + err); &#125; else &#123; for (var i = 0 ; i &lt; pr.upfiles.length ; i++) &#123; var inputFile = files.upfiles[i];//获取第一个文件 var finalname = inputFile.originalFilename; insertSQL_params.push(finalname) var new_name =__dirname+"/bower_components/uploads/"+finalname;//获取文件名 console.log(new_name) var old_name = inputFile.path;//获取文件路径 console.log(old_name) fs.renameSync(old_name,new_name); &#125; &#125; //添加数据到数据库 conn.query(insertSQL,insertSQL_params, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log("成功") &#125; &#125;) res.send("成功") &#125;)&#125;) 如有错误、意见、建议，欢迎提出。]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nodeJS创建简单学生管理系统]]></title>
    <url>%2F20160310%2Fnode-student-sys%2F</url>
    <content type="text"><![CDATA[安装并起一个服务： 一：nodeJS下载安装。 1.nodeJS下载安装不再赘述，官网：https://nodejs.org 2.npm安装模块语法：npm install _xxx_ 二：创建一个服务器，开启第一个应用。 用nodeJS的express框架创建一个服务器： (以express框架为例子创建应用)express框架封装了http模块相比更加简洁, 首先要安装express模块 npm install express 12345678// app.jsvar express = require(&quot;express&quot;);//引入express模块var app = express();//将express()对象赋给appvar port = 3000;//设置端口号app.get(&quot;/ &quot;,function (req,res) &#123; res.send(&quot;hello world&quot;)&#125;)app.listen(port);//监听端口 在正式开始之前先看看项目结构： 简单的介绍一下：前端主要使用bootstrap，jade模板，jQuery，ajax实现异步请求，由于前台页面文件较多，限于篇幅就不加上来了。后台逻辑也主要是对数据库的增删查改，对代码没有做任何的优化 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275//app.jsvar express = require(&quot;express&quot;);//导入express模块var path = require(&apos;path&apos;);//路径配置模块var bodyParser = require(&apos;body-parser&apos;)//页面传递参数解析var mysql = require(&apos;mysql&apos;);//mysql模块var multiparty = require(&apos;multiparty&apos;);//文件上传模块var util = require(&apos;util&apos;);var fs = require(&apos;fs&apos;);var app = express(); var port = 3000;//端口号app.set(&quot;views&quot;,&quot;views/pages/&quot;);//设置视图文件路径app.set(&quot;view engine&quot;,&quot;jade&quot;);//设置模板引擎app.use(express.static(path.join(__dirname,&apos;bower_components&apos;)))//设置静态文件路径app.use(bodyParser.urlencoded(&#123;extended: true,&#125;))app.listen(port);//监听端口console.log(&quot;start...&quot;+port);console.log(&apos;连接开始&apos;);//创建连接数据库var conn = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;root&apos;, database:&apos;stu_manage_system&apos;, port: 3306,&#125;);conn.connect();//连接数据库 //登录app.get(&quot;/login&quot;,function (req,res) &#123; res.render(&apos;login&apos;,&#123; title:&quot;欢迎登录学生管理系统&quot; &#125;)&#125;)//添加学生页面app.get(&quot;/insert&quot;,function (req,res) &#123; res.render(&apos;insert&apos;,&#123; title:&quot;添加学生页面&quot; &#125;)&#125;)//删除学生页面 deleteapp.get(&quot;/delete&quot;,function (req,res) &#123; var pat = &apos;delete&apos; var title = &quot;删除学生页面&quot; search(pat,res,title)//调用数据库查询方法&#125;)//查询学生页面 searchapp.get(&quot;/search&quot;,function (req,res) &#123; var title = &quot;查询学生页面&quot; var pat = &quot;search&quot; search(pat,res,title)//调用数据库查询方法&#125;)//修改学生信息页面 updateapp.get(&quot;/update&quot;,function (req,res) &#123; var title = &quot;修改学生信息页面&quot; var pat = &quot;update&quot; search(pat,res,title)//调用数据库查询方法&#125;)//注册 registeapp.post(&quot;/admin/registe&quot;,function (req,res) &#123; var username = req.body.username; var password = req.body.password; console.log(&quot;username:&quot;+username+&quot;password:&quot;+password) var insertSQL = &apos;insert into admin values(0,?,?)&apos;; var insertSQL_params = [username, password]; var selectSQL = &apos;select * from admin &apos;; conn.query(selectSQL, function (err2, rows) &#123; //var arrusername = new Array(); if (err2)&#123; console.log(err2); &#125;else&#123; console.log(rows.length) if(rows.length == 0)&#123; conn.query(insertSQL,insertSQL_params, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log(&quot;成功录入数据&quot;); &#125; &#125;) res.send(&#123;name:1&#125;) return true &#125;else&#123; for (var i = 0;i &lt; rows.length;i++) &#123; if(username == rows[i].username )&#123; res.send(&#123;name:0&#125;) return false //res.send(&quot;dd&quot;) &#125;else&#123; if(i &gt;= rows.length-1)&#123; conn.query(insertSQL,insertSQL_params, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log(&quot;成功录入数据&quot;); &#125; &#125;) res.send(&#123;name:1&#125;) return true &#125; &#125; &#125; &#125; &#125; &#125;) &#125;)//登录 loginapp.post(&quot;/admin/login&quot;,function (req,res) &#123; var username = req.body.username; var password = req.body.password; var selectSQL = &apos;select * from admin &apos;; conn.query(selectSQL, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; for (var i = 0;i&lt; rows.length;i++) &#123; if(rows[i].username == username &amp;&amp; rows[i].password == password)&#123; res.send(&#123;msg:1&#125;) return true &#125;else&#123; if (i &gt;= rows.length-1) &#123; res.send(&#123;msg:0&#125;) return false &#125; &#125; &#125; &#125; &#125;) &#125;)//数据库查询方法function search(pat,res,title)&#123; var selectSQL = &apos;select id,name,number,sex,age,img from student &apos;; conn.query(selectSQL, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; var arr = new Array() for(var item in rows)&#123; arr.push(rows[item]) &#125; res.render(pat,&#123; title:title, values:arr &#125;) &#125; &#125;) &#125;//添加学生页面 insertapp.post(&quot;/login&quot;,function(req,res)&#123; var insertSQL = &apos;insert into student values(0,?,?,?,?,?)&apos;; var insertSQL_params = []; var form = new multiparty.Form();//实例一个multiparty form.uploadDir = __dirname+&quot;/bower_components/uploads/&quot;;//设置文件储存路径 //开始解析前台传过来的文件 form.parse(req, function(err, fields, files) &#123; for (var item in fields)&#123; insertSQL_params.push(fields[item][0]) console.log(fields[item][0]) &#125; var filesTmp = JSON.stringify(files); var pr = JSON.parse(filesTmp) console.log(pr.upfiles.length) if(err)&#123; console.log(&apos;parse error: &apos; + err); &#125; else &#123; for (var i = 0 ; i &lt; pr.upfiles.length ; i++) &#123; var inputFile = files.upfiles[i];//获取第一个文件 var finalname = inputFile.originalFilename; insertSQL_params.push(finalname) var new_name =__dirname+&quot;/bower_components/uploads/&quot;+finalname;//获取文件名 console.log(new_name) var old_name = inputFile.path;//获取文件路径 console.log(old_name) fs.renameSync(old_name,new_name); &#125; &#125; //添加数据到数据库 conn.query(insertSQL,insertSQL_params, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log(&quot;成功&quot;) &#125; &#125;) res.render(&apos;insert&apos;,&#123; title:&quot;添加学生页面&quot; &#125;) &#125;)&#125;);app.post(&quot;/delete&quot;,function(req,res)&#123; var getid = req.body.id; var selectSQL = &apos;select id from student &apos;; conn.query(selectSQL, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; for (var item in rows) &#123; if (getid == rows[item].id) &#123; var deleteSQL = &apos;delete from student where id = &apos;+getid+&quot;&quot;; conn.query(deleteSQL, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log(&quot;dyuityfdgdd&quot;) &#125; &#125;) &#125; &#125; &#125; &#125;) res.send(&quot;ddd&quot;)&#125;)app.post(&apos;/update&apos;,function(req,res)&#123; var form = new multiparty.Form();//实例一个multiparty form.uploadDir = __dirname+&quot;/bower_components/uploads/&quot;;//设置文件储存路径 //开始解析前台传过来的文件 form.parse(req, function(err, fields, files) &#123; console.log(fields) var filesTmp = JSON.stringify(files); var pr = JSON.parse(filesTmp) if(err)&#123; console.log(&apos;parse error: &apos; + err); &#125; else &#123; for (var i = 0 ; i &lt; pr.upfiles.length ; i++) &#123; console.log(files.upfiles[i]) var inputFile = files.upfiles[i];//获取第一个文件 var finalname = inputFile.originalFilename; //文件名 if(finalname == &apos;&apos;)&#123; var updataSQL01 = &apos;update student set name = ?,number = ?,sex = ?,age = ? where id = ?&apos;; var updataSQL_params01 = [] for(var item in fields)&#123; console.log(fields[item][0]) updataSQL_params01.push(fields[item][0]) &#125; conn.query(updataSQL01,updataSQL_params01, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log(&quot;成功&quot;) return res.redirect(&quot;/update&quot;) ; &#125; &#125;) &#125;else&#123; var updataSQL02 = &apos;update student set name = ?,number = ?,sex = ?,age = ?,img = ? where id = ?&apos;; var updataSQL_params02 = [] for(var item in fields)&#123; updataSQL_params02.push(fields[item][0]) &#125; updataSQL_params02.splice(4,0,finalname) var new_name =__dirname+&quot;/bower_components/uploads/&quot;+finalname;//获取文件路径 var old_name = inputFile.path;//获取文件路径 fs.renameSync(old_name,new_name);//改名 conn.query(updataSQL02,updataSQL_params02, function (err2, rows) &#123; if (err2)&#123; console.log(err2); &#125;else&#123; console.log(&quot;成功&quot;) return res.redirect(&quot;/update&quot;) ; &#125; &#125;) &#125; &#125; &#125; &#125;)&#125;) 下面是js registe.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//registe.js$(function()&#123; $(&quot;.loginsubmit&quot;).click(function()&#123; var usernameval = $(&quot;.username&quot;).val() var passwordval = $(&quot;.password&quot;).val() if(usernameval == &quot;&quot; || passwordval == &quot;&quot;)&#123; alert(&quot;用户名或密码不能为空&quot;) &#125;else &#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/admin/login&quot;, timeout:3000, data: &#123;username:usernameval, password:passwordval&#125;, success: function(date)&#123; if (date.msg == 1) &#123; alert(&quot;登录成功,点击确定跳转&quot;); window.location.href = &quot;/insert&quot; &#125;else&#123; alert(&quot;登录失败,用户名或密码错误&quot;) &#125; &#125;, error:function(date)&#123; alert(&quot;提交失败&quot;) &#125; &#125;) &#125; &#125;); $(&apos;#click&apos;).click(function()&#123; $(&quot;#content&quot;).empty(); $(&quot;h1&quot;).text(&quot;欢迎注册学生管理系统管理员&quot;); $(&quot;#content&quot;).append( &quot;&lt;form class = &apos;loginForm&apos; &gt;&quot;+ &quot;&lt;input class = &apos;username&apos; type = &apos;text&apos; placeholder = &apos;用户名&apos; &gt;&quot;+ &quot;&lt;input class = &apos;password&apos; type = &apos;password&apos; placeholder = &apos;密码&apos;&gt;&quot;+ &quot;&lt;input class = &apos;registesubmit submit&apos; type = &apos;button&apos; value = &apos;注册&apos;&gt;&quot;+ &quot;&lt;h6 style = &apos;text-align:center&apos;&gt;有账号去&quot;+ &quot;&lt;a id = &apos;click&apos; href = &apos;/login&apos;&gt; 登录&lt;/a&gt;&quot;+ &quot;&lt;/h6&gt;&quot;+ &quot;&lt;/form&gt;&quot;); $(&quot;.registesubmit&quot;).click(function()&#123; var usernameval = $(&quot;.username&quot;).val() var passwordval = $(&quot;.password&quot;).val() if(usernameval == &quot;&quot; || passwordval == &quot;&quot;)&#123; alert(&quot;用户名或密码不能为空&quot;) &#125;else &#123; $.ajax(&#123; type: &quot;POST&quot;, timeout:3000, url: &quot;/admin/registe&quot;, data: &#123;username:usernameval, password:passwordval&#125;, success: function(dat)&#123; if (dat.name == 1 ) &#123; alert(&quot;注册成功,点击确定返回登录页&quot;+dat.name); window.location.href = &quot;/login&quot; &#125;else&#123; alert(&quot;注册失败，该用户已存在&quot;) &#125; &#125;, error:function(dat)&#123; alert(&quot;提交失败&quot;+dat.name) &#125; &#125;) &#125; &#125;) &#125;)&#125;) delete.js 1234567891011121314//delete.jsfunction del(obj)&#123; $.ajax(&#123; url:&quot;/delete&quot;, type:&quot;post&quot;, data:&#123;id:obj.id&#125;, success:function(dat)&#123; window.location.href = &quot;/delete&quot; &#125;, error:function(dat)&#123; alert(&quot;失败&quot;) &#125; &#125;)&#125; update.js 12345678910111213141516171819202122232425262728293031323334353637383940414243function remove_DOM(obj)&#123; var objid = obj.id//获取id var img = $(&apos;#img&apos;+objid).attr(&quot;src&quot;) var name = $(&apos;#name&apos;+objid).text() var number = $(&apos;#number&apos;+objid).text() var sex = $(&apos;#sex&apos;+objid).text() var age = $(&apos;#age&apos;+objid).text() $(&apos;.con&apos;).empty() $(&apos;.con&apos;).append( &apos;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/update&quot; class=&quot;loginForm&quot;&gt;&apos;+ &apos;&lt;div class=&quot;upload&quot;&gt;&apos;+ &apos;&lt;span&gt;姓名:&lt;input type=&quot;text&quot; name = &quot;name&quot; placeholder=&quot;姓名&quot; class=&quot;stuMsg stu_name&quot;&gt;&lt;/span&gt;&apos;+ &apos;&lt;/div&gt;&apos;+ &apos;&lt;div class=&quot;upload&quot;&gt;&apos;+ &apos;&lt;span&gt;学号:&lt;input type=&quot;text&quot; name = &quot;number&quot; placeholder=&quot;学号&quot; class=&quot;stuMsg stu_number&quot;&gt;&lt;/span&gt;&apos;+ &apos;&lt;/div&gt;&apos;+ &apos;&lt;div class=&quot;upload&quot;&gt;&apos;+ &apos;&lt;span&gt;性别:&lt;input type=&quot;text&quot; name = &quot;sex&quot; placeholder=&quot;性别&quot; class=&quot;stuMsg stu_sex&quot;&gt;&lt;/span&gt;&apos;+ &apos;&lt;/div&gt;&apos;+ &apos;&lt;div class=&quot;upload&quot;&gt;&apos;+ &apos;&lt;span&gt;年龄:&lt;input type=&quot;text&quot; name = &quot;age&quot; placeholder=&quot;年龄&quot; class=&quot;stuMsg stu_age&quot;&gt;&lt;/span&gt;&apos;+ &apos;&lt;/div&gt;&apos;+ &apos;&lt;div id=&quot;containimg&quot; class=&quot;upload&quot;&gt;&apos;+ &apos;&lt;span&gt;头像:&lt;input type=&quot;file&quot; name=&quot;upfiles&quot; multiple=&quot;mutiple&quot; class=&quot;stuMsg stu_img&quot;&gt;&lt;/span&gt;&apos;+ &apos;&lt;/div&gt;&apos;+ &apos;&lt;input type=&quot;text&quot; name=&quot;hiddenid&quot; class=&quot;stuMsg hiddenid&quot;&gt;&apos;+ &apos;&lt;div class=&quot;upload&quot;&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;录入&quot; class=&quot;stuMsg addmsg&quot;&gt;&apos;+ &apos;&lt;/div&gt;&apos;+ &apos;&lt;/form&gt;&apos; ) $(&apos;.stu_name&apos;).val(name) $(&apos;.stu_number&apos;).val(number) $(&apos;.stu_sex&apos;).val(sex) $(&apos;.stu_age&apos;).val(age) $(&apos;.hiddenid&apos;).val(objid)&#125;]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
  </entry>
</search>
